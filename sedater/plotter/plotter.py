# ./sedater/plotter/plotter.py
# Author:   Ulli Goschler <ulligoschler@gmail.com>
# Modified: Thu, 10.12.2015 - 20:08:46

import os, sys
import numpy as np
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid.anchored_artists import AnchoredText

import xml.etree.ElementTree as et

class Plotter(object):
    """
    The main plotting utility.

    By default it plots two different graphs for each (Sensor)
    input file:

    * The acceration in X, Y, Z
    * The gyroscope in X, Y, Z

    .. attention::
        It is currently not possible to read a header/comment line from
        the ``.csv`` file and therefore determine the order of
        arguments.
        The order of values has to be:

        .. code-block:: none
            :linenos:

            Index, accelX, accelY, accelZ, gyroX, gyroY, gyroZ

    If an Annotationfile is provided, the Validation ``Pattern``-type
    will be extracted and an overlay generated, indicating the 
    Gold Standard.

    :param str annotationFile: Path to the Annotationfile from 
            which an Gold Standard overlay will be generated
    :param bool headerline: Specify if the ``.csv``-file has a 
        header/comment line
    :param str outputDir: Directory where to put the plots
    :param list graph: Specify which graphs should be plotted
    """

    def __init__(self, graph, 
              annotationFile=False
            , outputDir=False
            , headerline=False):
        self.headerline = headerline
        self.graph = graph
        # i hope these default colors are visible for colorblinds
        self.colors = ['Darkred', 'ForestGreen', 'Navy']
        self.outputDir = outputDir
        self.annotationFile = annotationFile
        # multiplot feature disabled
        self.multiplot = False

    def plot(self, sourceFile, orientation):
        """
        Plot a given ``.csv`` RawValidation file.

        :param str sourceFile: Path to the to-be-plotted file
        :param str orientation: Identification which sensor to plot
        """
        # gather overlay data
        if self.annotationFile:
            overlay = self._extractOverlayData(self.annotationFile, orientation)
        else:
            overlay = False

        # build plot export location
        if self.outputDir:
            outputDir = self.outputDir
        else:
            outputDir = os.path.dirname(sourceFile) + '/'
        accelFile = outputDir + 'accel-' +\
            os.path.splitext(os.path.basename(sourceFile))[0] + '.svg'
        gyroFile = outputDir + 'gyro-' +\
            os.path.splitext(os.path.basename(sourceFile))[0] + '.svg'

        src = self._importFile(sourceFile)
        self._plotData('accel', src, sourceFile, accelFile, overlay)
        self._plotData('gyro', src, sourceFile, gyroFile, overlay)

    def _extractOverlayData(self, xmlFile, sensorOrientation):
        """
        Gather Validationdata from a xml file, to plot it as Overlay.

        The xml Annotationfile - created by :ref:`sedater` -
        has usually a Validation section for the (foot) ``pattern``-type.
        These values are generated by the Validationtxt files and considered
        as Gold Standard parameters.

        .. code-block:: none
            :linenos:

            [...]
            <Validation Type="PATTERN">
              <Sensor Orientation="right">
                [...]
                <Content>
                  <No1>
                    <Start>35</Start>
                    <End>154</End>
                  </No1>
              [...]

        The patterns (here: line 7-8) of a certain Sensor are extracted
        and returned.

        :param str xmlFile: Path to the xml-Annotationfile
        :param str sensorOrientation: Sensor which should be extracted
        :return: Properties (start and stop) of each Gold Parameter step
        :rtype: ``list(dict())``
        """
        tree = et.parse(xmlFile)

        goldStandardXML = tree.findall('.//Validation[@Type="PATTERN"]/'
            'Sensor[@Orientation="'+sensorOrientation+'"]/Content/')
        if goldStandardXML:
            exp = []
            for steps in goldStandardXML:
                title = steps.tag
                for step in steps:
                    if step.tag.lower() == 'start':
                        start = step.text
                    elif step.tag.lower() == 'end':
                        end = step.text
                try:
                    properties = {'id': title, 'start': start, 'end': end}
                    exp.append(properties)
                except Exception:
                    return False
        else:
            return False

        return exp

    def _plotData(self, identity, src, plotFile, outputFile, overlay):
        """
        Plots the ``numpy`` parsed data to ``.svg`` files.


        See :class:`this <Plotter._extractOverlayData>` documentation
        for more details on the overlay.

        :param str identity: Identity of the plot. Can either be ``accel`` 
            or ``gyro``
        :param numpy src: ``numpy``-parsed Datasource
        :param str plotFile: Path to the Datasource, which will be plotted as title
        :param str outputFile: Path to the newly plotted graph
        :param bool overlay: Display the Gold Standard Overlay

        """
        # determine the max y-values for best overlay placement
        maxima = []
        acceleration = plt.figure()

        if self.multiplot:
            plots = len(self.graph[0])
        else:
            # create only one plot
            ax = acceleration.add_subplot(111)
            plots = 1

        if identity == 'accel':
            source = self.graph[0]
            identityLong = 'Acceleration'
        elif identity == 'gyro':
            source = self.graph[1]
            identityLong = 'Gyroscope'

        for i, accel in enumerate(source):
            j = i + 1 if self.multiplot else 1
            ax = acceleration.add_subplot(plots,1,j)
            ax.set_title('{} of {}'.format(identityLong, plotFile))
            ax.plot(
                  src['x']
                , src[accel]
                , color=self.colors[i]
                , label=accel)
            maxima.append(max(src[accel]))
        if overlay:
            # place overlay arrows at 1/3 of y-max
            yOverlay = 0.3 * max(maxima)
            legend = []
            for gs in overlay:
                ax.annotate(''
                        , xy=(gs['start'],yOverlay)
                        , xycoords='data'
                        , xytext=(gs['end'],yOverlay)
                        , textcoords='data'
                        , horizontalalignment='bottom'
                        , verticalalignment='center'
                        , arrowprops=dict(
                              arrowstyle="<|-|>"
                            , fc="white"
                            , ec="black"
                            , alpha=0.5
                            )
                        ).set_alpha(0.5)
                legend.append(gs['id']+": "+gs['start']+"-"+gs['end'])

            at = AnchoredText("Gold Standard:\n"+"\n".join(legend),
                    prop=dict(size=10), loc=4)
            at.patch.set_boxstyle("round")
            at.patch.set_alpha(0.5)
            ax.add_artist(at)

        ax.legend(
                  loc=1
                , fontsize=10
                , fancybox=True).get_frame().set_alpha(0.5)
        # plt.show()
        plt.savefig(outputFile, format='svg')

    def _importFile(self, sourceFile):
        """
        Parses the given ``CSV``-file for ``numpy``.

        Imports the columns as listed unter 'names'.

        :param str sourceFile: Path to the to-be-plotted-file
        :return: ``numpy``-parsed data
        :rtype: ``numpy``-object
        """
        header = 1 if self.headerline else 0

        data = np.genfromtxt(
                  sourceFile
                , delimiter=','
                , skip_header=header
                , names=[
                      'x'
                    , 'accelX'
                    , 'accelY'
                    , 'accelZ'
                    , 'gyroX'
                    , 'gyroY'
                    , 'gyroZ'
                    ]
                )
        return data
